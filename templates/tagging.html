{% extends "base.html" %}

{% block head %}
{{ super() }}
<!-- Element Plus ä¸­æ–‡è¯­è¨€åŒ… -->
<script src="{{ url_for('static', filename='vendor/vue/zh-cn.min.js') }}"></script>
{% endblock %}

{% block content %}
<!-- ==================== è´¦å•ç®¡ç†ç•Œé¢ ==================== -->
<div id="app">
    <el-card class="mb-3">
        <!-- å¡ç‰‡å¤´éƒ¨ï¼šè´¦å•ç±»å‹é€‰æ‹© + æ“ä½œæŒ‰é’® -->
        <template #header>
            <div class="d-flex justify-content-between align-items-center">
                <div class="d-flex align-items-center tagging-header-meta">
                    <span>è´¦å•æ•°æ®</span>
                    <div class="stats-box text-muted tagging-stats-summary">
                        [[ billStats.total ]] / (tag, [[ billStats.tagTagged ]], [[ billStats.tagPercentage.toFixed(2)
                        ]]% ||
                        catg, [[ billStats.categoryTagged ]], [[ billStats.categoryPercentage.toFixed(2) ]]%)
                    </div>
                </div>
                <div class="d-flex header-btn-group">
                    <el-select v-model="billType" placeholder="é€‰æ‹©è´¦å•ç±»å‹" class="tagging-select-100">
                        <el-option label="æ”¯ä»˜å®" value="alipay"></el-option>
                        <el-option label="å¾®ä¿¡" value="wechat"></el-option>
                    </el-select>
                    <el-upload action="/upload" :on-success="handleUploadSuccess" :on-error="handleUploadError"
                        :before-upload="beforeUpload" :show-file-list="false" :data="{ bill_type: billType }"
                        name="file" accept=".xlsx,text/csv">
                        <el-button type="primary">
                            ä¸Šä¼ è´¦å•
                        </el-button>
                    </el-upload>
                    <el-button type="success" @click="handleExport"
                        :disabled="!filteredBillsData.length">å¯¼å‡ºè´¦å•</el-button>
                    <el-button type="danger" @click="handleClearCache" :disabled="!bills.length">æ¸…é™¤ç¼“å­˜</el-button>
                </div>
            </div>
        </template>

        <!-- å·¥å…·æ ï¼šç»Ÿè®¡ä¿¡æ¯ + ç­›é€‰æ§ä»¶ -->
        <div class="d-flex justify-content-between align-items-center mb-3">

            <div class="d-flex align-items-center gap-4">

                <el-input v-model="searchQuery" placeholder="æœç´¢å…³é”®å­—(null ä¸ºç©ºå€¼)" clearable @input="handleFilterChange"
                    class="tagging-input-180"></el-input>
                <el-select v-model="searchField" placeholder="æŒ‡å®šæœç´¢å­—æ®µ" @change="handleFilterChange"
                    class="tagging-select-130" clearable>
                    <el-option label="äº¤æ˜“å¯¹æ–¹" value="äº¤æ˜“å¯¹æ–¹"></el-option>
                    <el-option label="å•†å“è¯´æ˜" value="å•†å“è¯´æ˜"></el-option>
                    <el-option label="ç±»åˆ«" value="ç±»åˆ«"></el-option>
                    <el-option label="æ ‡ç­¾" value="æ ‡ç­¾"></el-option>
                </el-select>
                <el-select v-model="mealType" placeholder="é¤ç‚¹ç±»å‹" @change="handleFilterChange" class="tagging-select-100"
                    clearable>
                    <el-option label="æ—©é¤" value="æ—©é¤"></el-option>
                    <el-option label="åˆé¤" value="åˆé¤"></el-option>
                    <el-option label="æ™šé¤" value="æ™šé¤"></el-option>
                    <el-option label="å¤œå®µ" value="å¤œå®µ"></el-option>
                </el-select>
                <el-checkbox v-model="showUntaggedOnly" @change="handleFilterChange">åªçœ‹æœªæ ‡è®°</el-checkbox>
                <el-select v-model="frequencySortField" placeholder="æŒ‰é¢‘ç‡æ’åº" class="tagging-select-120"
                    @change="handleFilterChange" clearable>
                    <el-option label="æŒ‰äº¤æ˜“å¯¹æ–¹" value="äº¤æ˜“å¯¹æ–¹"></el-option>
                    <el-option label="æŒ‰å•†å“è¯´æ˜" value="å•†å“è¯´æ˜"></el-option>
                </el-select>
            </div>
            <div class="d-flex align-items-center gap-2">
                <el-button type="primary" @click="handleStartTagging" :disabled="!bills.length">
                    [[ isEditing ? 'ä¿å­˜æ•°æ®' : 'å¼€å§‹æ‰“æ ‡' ]]
                </el-button>
                <el-button type="primary" @click="handleBatchTag"
                    :disabled="!isEditing || !selectedBills.length">æ‰¹é‡æ‰“æ ‡</el-button>
                <el-button type="warning" @click="handleAITag" :disabled="!isEditing || !bills.length"
                    :loading="aiTagLoading">
                    AI æ‰“æ ‡
                </el-button>

                <el-button type="danger" @click="resetFilters">é‡ç½®ç­›é€‰</el-button>
            </div>
        </div>

        <!-- è´¦å•è¡¨æ ¼ -->
        <div class="table-container">
            <el-table :data="paginatedBills" class="tagging-table-full" stripe :max-height="560"
                @sort-change="handleSortChange" :empty-text="emptyText" :row-key="row => row.äº¤æ˜“è®¢å•å·"
                :default-sort="{ prop: 'äº¤æ˜“æ—¶é—´', order: 'ascending' }" @selection-change="handleSelectionChange"
                v-loading="loading" :virtual-scrolling="true" :scrollbar-always-on="true">
                <!-- åºå·åˆ—ï¼ˆéç¼–è¾‘æ¨¡å¼ï¼‰ -->
                <el-table-column type="index" label="åºå·" width="60" align="center" v-if="!isEditing">
                    <template #default="scope">[[ (currentPage - 1) * pageSize + scope.$index + 1 ]]</template>
                </el-table-column>
                <!-- é€‰æ‹©åˆ—ï¼ˆç¼–è¾‘æ¨¡å¼ï¼‰ -->
                <el-table-column type="selection" width="60" align="center" v-if="isEditing"></el-table-column>
                <!-- æ—¥æœŸåˆ— -->
                <el-table-column prop="äº¤æ˜“æ—¶é—´" label="æ—¥æœŸ" width="180" align="center" sortable="custom"></el-table-column>
                <!-- é‡‘é¢åˆ— -->
                <el-table-column prop="é‡‘é¢" label="é‡‘é¢" width="120" align="center" sortable="custom">
                    <template #default="scope">
                        <el-input-number v-if="isEditing" v-model="scope.row.é‡‘é¢" :precision="2" :step="0.01"
                            size="small" @change="markModified(scope.row)" class="tagging-input-number-90"
                            :controls="false"></el-input-number>
                        <span v-else :class="scope.row.é‡‘é¢ < 0 ? 'stats-amount-negative' : 'stats-amount-positive'">
                            <span>[[ formatAmount(scope.row.é‡‘é¢) ]]</span>
                        </span>
                    </template>
                </el-table-column>
                <!-- ç±»åˆ«åˆ— -->
                <el-table-column prop="ç±»åˆ«" label="ç±»åˆ«" width="120" align="center" :filters="categoryFilterOptions"
                    :filter-method="filterCategory">
                    <template #default="scope">
                        <el-select v-if="isEditing" v-model="scope.row.ç±»åˆ«" size="small" class="tagging-select-80"
                            clearable @change="handleCategoryChange(scope.row)" filterable>
                            <el-option v-for="cat in categories" :key="cat" :label="cat" :value="cat"></el-option>
                        </el-select>
                        <span v-else-if="scope.row.ç±»åˆ«" class="tagging-inline-center">
                            <el-tag size="default" effect="plain" :style="getCategoryIconTagStyle(scope.row.ç±»åˆ«)">
                                <el-icon size="16">
                                    <component :is="getCategoryIconComponent(scope.row.ç±»åˆ«)" />
                                </el-icon>
                            </el-tag>
                            <span class="tagging-text-primary">[[ scope.row.ç±»åˆ« ]]</span>
                        </span>
                        <span v-else></span>
                    </template>
                </el-table-column>
                <!-- æ ‡ç­¾åˆ— -->
                <el-table-column prop="æ ‡ç­¾" label="æ ‡ç­¾" width="120" align="center" :filters="tagFilterOptions"
                    :filter-method="filterTag">
                    <template #default="scope">
                        <el-select v-if="isEditing" v-model="scope.row.æ ‡ç­¾" size="small" class="tagging-select-80"
                            clearable @change="markModified(scope.row)" filterable>
                            <el-option v-for="tag in getTagsForCategory(scope.row.ç±»åˆ«)" :key="tag" :label="tag"
                                :value="tag"></el-option>
                        </el-select>
                        <el-tag v-else-if="scope.row.æ ‡ç­¾ && scope.row.æ ‡ç­¾ !== '-'" size="default" effect="plain"
                            :style="getCategoryTagStyle(scope.row.ç±»åˆ«)">
                            <span>[[ scope.row.æ ‡ç­¾ ]]</span>
                        </el-tag>
                        <span v-else-if="scope.row.æ ‡ç­¾ === '-'">[[ scope.row.æ ‡ç­¾ ]]</span>
                        <span v-else></span>
                    </template>
                </el-table-column>
                <!-- å…¶ä»–åˆ— -->
                <el-table-column prop="äº¤æ˜“å¯¹æ–¹" label="äº¤æ˜“å¯¹æ–¹" min-width="120" sortable header-align="center">
                    <template #default="scope">
                        <span class="selectable-text" @mouseup="handleTextSelect($event, 'äº¤æ˜“å¯¹æ–¹', scope.row)">
                            [[ scope.row.äº¤æ˜“å¯¹æ–¹ ]]
                        </span>
                    </template>
                </el-table-column>
                <el-table-column prop="å•†å“è¯´æ˜" label="å•†å“è¯´æ˜" min-width="120" sortable header-align="center">
                    <template #default="scope">
                        <span class="selectable-text" @mouseup="handleTextSelect($event, 'å•†å“è¯´æ˜', scope.row)">
                            [[ scope.row.å•†å“è¯´æ˜ ]]
                        </span>
                    </template>
                </el-table-column>
                <el-table-column prop="å¤‡æ³¨" label="å¤‡æ³¨" width="100" header-align="center">
                    <template #default="scope">
                        <el-input v-if="isEditing" v-model="scope.row.å¤‡æ³¨" size="small" @change="markModified(scope.row)"
                            class="tagging-field-full"></el-input>
                        <span v-else>[[ scope.row.å¤‡æ³¨ ]]</span>
                    </template>
                </el-table-column>
                <el-table-column prop="å‘½ä¸­è§„åˆ™" label="å‘½ä¸­è§„åˆ™" min-width="150" header-align="center">
                    <template #default="scope">
                        <el-input v-if="isEditing" v-model="scope.row.å‘½ä¸­è§„åˆ™" size="small"
                            @change="markModified(scope.row)" class="tagging-field-full"></el-input>
                        <span v-else>[[ scope.row.å‘½ä¸­è§„åˆ™ ]]</span>
                    </template>
                </el-table-column>
            </el-table>

            <!-- åˆ†é¡µå™¨ -->
            <div class="pagination-container pagination-container-compact">
                <el-pagination v-model:current-page="currentPage" v-model:page-size="pageSize"
                    :page-sizes="[100, 500, 1000, 5000, 10000]" layout="total, sizes, prev, pager, next, jumper"
                    :total="filteredBillsData.length" @size-change="val => { pageSize = val; currentPage = 1; }"
                    @current-change="val => currentPage = val">
                </el-pagination>
            </div>
        </div>
    </el-card>

    <!-- æ‰¹é‡æ‰“æ ‡å¯¹è¯æ¡† -->
    <el-dialog v-model="batchTagDialogVisible" title="æ‰¹é‡æ‰“æ ‡" width="500px" :close-on-click-modal="false">
        <el-form :model="batchTagForm" label-width="80px">
            <el-form-item label="ç±»åˆ«">
                <el-select v-model="batchTagForm.category" placeholder="é€‰æ‹©æˆ–è¾“å…¥ç±»åˆ«" class="tagging-select-full" filterable
                    allow-create default-first-option @change="batchTagForm.tag = ''">
                    <el-option v-for="cat in categories" :key="cat" :label="cat" :value="cat"></el-option>
                </el-select>
            </el-form-item>
            <el-form-item label="æ ‡ç­¾">
                <el-select v-model="batchTagForm.tag" placeholder="é€‰æ‹©æˆ–è¾“å…¥æ ‡ç­¾" class="tagging-select-full" filterable
                    allow-create default-first-option>
                    <el-option v-for="tag in categoryTags[batchTagForm.category] || []" :key="tag" :label="tag"
                        :value="tag"></el-option>
                </el-select>
            </el-form-item>
            <el-form-item label="å¤‡æ³¨">
                <el-input v-model="batchTagForm.comment" placeholder="è¯·è¾“å…¥å¤‡æ³¨"></el-input>
            </el-form-item>
        </el-form>
        <template #footer>
            <el-button @click="batchTagDialogVisible = false">å–æ¶ˆ</el-button>
            <el-button type="primary" @click="applyBatchTag">ç¡®å®š</el-button>
        </template>
    </el-dialog>

    <!-- AI æ‰“æ ‡ç»“æœå¯¹è¯æ¡† -->
    <el-dialog v-model="aiTagDialogVisible" title="AI æ‰“æ ‡ç»“æœ" width="900px" :close-on-click-modal="false">
        <div class="ai-tag-results">
            <!-- æ‰“æ ‡ç»“æœè¡¨æ ¼ -->
            <div class="mb-4">
                <h4 class="mb-2">ğŸ“‹ æ‰“æ ‡ç»“æœï¼ˆ[[ aiTagResults.tagged_bills.length ]] æ¡ï¼‰</h4>
                <el-table :data="aiTagResults.tagged_bills" border stripe max-height="250"
                    @selection-change="handleAITagSelection" ref="aiTagTableRef">
                    <el-table-column type="selection" width="55" align="center"></el-table-column>
                    <el-table-column prop="äº¤æ˜“è®¢å•å·" label="è®¢å•å·" width="180" show-overflow-tooltip></el-table-column>
                    <el-table-column prop="ç±»åˆ«" label="ç±»åˆ«" width="80" align="center"></el-table-column>
                    <el-table-column prop="æ ‡ç­¾" label="æ ‡ç­¾" width="100" align="center"></el-table-column>
                    <el-table-column prop="å¤‡æ³¨" label="å¤‡æ³¨" show-overflow-tooltip></el-table-column>
                </el-table>
            </div>

            <!-- è§„åˆ™å»ºè®®è¡¨æ ¼ -->
            <div v-if="aiTagResults.suggested_rules.length">
                <h4 class="mb-2">ğŸ’¡ è§„åˆ™å»ºè®®ï¼ˆ[[ aiTagResults.suggested_rules.length ]] æ¡ï¼‰</h4>
                <el-table :data="aiTagResults.suggested_rules" border stripe max-height="200"
                    @selection-change="handleRuleSelection" ref="ruleTableRef">
                    <el-table-column type="selection" width="55" align="center"></el-table-column>
                    <el-table-column prop="key" label="åŒ¹é…å­—æ®µ" width="100" align="center"></el-table-column>
                    <el-table-column label="å…³é”®è¯" width="180">
                        <template #default="scope">
                            <el-tag v-for="kw in scope.row.rule" :key="kw" size="small" class="me-1">[[ kw ]]</el-tag>
                        </template>
                    </el-table-column>
                    <el-table-column prop="category" label="ç±»åˆ«" width="80" align="center"></el-table-column>
                    <el-table-column prop="tag" label="æ ‡ç­¾" width="80" align="center"></el-table-column>
                    <el-table-column prop="comment" label="è¯´æ˜" show-overflow-tooltip></el-table-column>
                </el-table>
            </div>
        </div>
        <template #footer>
            <div class="d-flex justify-content-between align-items-center">
                <el-checkbox v-model="saveSelectedRules" v-if="selectedRules.length">
                    åŒæ—¶ä¿å­˜é€‰ä¸­çš„è§„åˆ™å»ºè®®
                </el-checkbox>
                <span v-else></span>
                <div>
                    <el-button @click="aiTagDialogVisible = false">å–æ¶ˆ</el-button>
                    <el-button type="primary" @click="applyAITagResults" :disabled="!selectedAITags.length">
                        åº”ç”¨é€‰ä¸­ï¼ˆ[[ selectedAITags.length ]] æ¡ï¼‰
                    </el-button>
                </div>
            </div>
        </template>
    </el-dialog>

    <!-- å¿«é€Ÿåˆ›å»ºè§„åˆ™å¼¹æ¡† -->
    <el-dialog v-model="quickRuleDialogVisible" title="å¿«é€Ÿåˆ›å»ºè§„åˆ™" width="500px" :close-on-click-modal="false"
        class="quick-rule-dialog">
        <el-form :model="quickRuleForm" label-width="80px">
            <el-form-item label="åŒ¹é…å­—æ®µ">
                <el-select v-model="quickRuleForm.key" placeholder="é€‰æ‹©åŒ¹é…å­—æ®µ">
                    <el-option label="äº¤æ˜“å¯¹æ–¹" value="äº¤æ˜“å¯¹æ–¹"></el-option>
                    <el-option label="å•†å“è¯´æ˜" value="å•†å“è¯´æ˜"></el-option>
                    <el-option label="ä»»æ„å­—æ®µ (äº¤æ˜“å¯¹æ–¹/å•†å“è¯´æ˜)" value="ANY"></el-option>
                </el-select>
            </el-form-item>
            <el-form-item label="å…³é”®è¯">
                <el-input v-model="quickRuleForm.keyword" placeholder="é€‰ä¸­çš„æ–‡æœ¬"></el-input>
            </el-form-item>
            <el-form-item label="åŒ¹é…æ¨¡å¼">
                <el-radio-group v-model="quickRuleForm.match_mode">
                    <el-radio label="keyword">å…³é”®è¯</el-radio>
                    <el-radio label="regex">æ­£åˆ™</el-radio>
                </el-radio-group>
            </el-form-item>
            <el-form-item>
                <template #label>
                    <div class="tagging-form-label-wrap">
                        <el-tooltip v-if="isNewCategory" content="å°†åˆ›å»ºæ–°ç±»åˆ«" placement="top">
                            <el-icon color="#E6A23C" :size="16" class="tagging-warning-icon">
                                <component :is="WarningFilled" />
                            </el-icon>
                        </el-tooltip>
                        <span>ç±»åˆ«</span>
                    </div>
                </template>
                <el-select v-model="quickRuleForm.category" placeholder="é€‰æ‹©æˆ–è¾“å…¥ç±»åˆ«" class="tagging-select-full" filterable
                    allow-create default-first-option @change="quickRuleForm.tag = ''">
                    <el-option v-for="cat in categories" :key="cat" :label="cat" :value="cat"></el-option>
                </el-select>
            </el-form-item>
            <el-form-item>
                <template #label>
                    <div class="tagging-form-label-wrap">
                        <el-tooltip v-if="isNewTag" content="å°†åˆ›å»ºæ–°æ ‡ç­¾" placement="top">
                            <el-icon color="#E6A23C" :size="16" class="tagging-warning-icon">
                                <component :is="WarningFilled" />
                            </el-icon>
                        </el-tooltip>
                        <span>æ ‡ç­¾</span>
                    </div>
                </template>
                <el-select v-model="quickRuleForm.tag" placeholder="é€‰æ‹©æˆ–è¾“å…¥æ ‡ç­¾" class="tagging-select-full" filterable
                    allow-create default-first-option>
                    <el-option v-for="tag in categoryTags[quickRuleForm.category] || []" :key="tag" :label="tag"
                        :value="tag"></el-option>
                </el-select>
                <div class="tagging-help-text">
                    æ ‡ç­¾ä¸º - æ—¶ï¼Œæ‰“æ ‡æ—¶å°†æ ¹æ®è´¦å•æ—¶é—´è‡ªåŠ¨å½’ç±»ä¸º æ—©/åˆ/æ™šé¤ä¸å¤œå®µ
                </div>
            </el-form-item>
            <el-form-item label="æ—¶é—´å½’ç±»" v-if="quickRuleForm.tag && quickRuleForm.tag === '-'">
                <el-select v-model="quickRuleForm.time_based" multiple placeholder="é€‰æ‹©æ—¶æ®µ" class="tagging-select-full"
                    @change="handleQuickRuleTimeBasedChange">
                    <el-option v-for="t in TIME_OPTIONS" :key="t" :label="t" :value="t"></el-option>
                </el-select>
            </el-form-item>
            <el-form-item label="å¤‡æ³¨">
                <el-input v-model="quickRuleForm.comment" placeholder="å¯é€‰ï¼Œç”¨äºè®°å½•è§„åˆ™ç”¨é€”"></el-input>
            </el-form-item>
        </el-form>
        <template #footer>
            <el-button @click="quickRuleDialogVisible = false">å–æ¶ˆ</el-button>
            <el-button type="primary" @click="saveQuickRule"
                :disabled="!quickRuleForm.keyword || !quickRuleForm.category">ä¿å­˜è§„åˆ™</el-button>
        </template>
    </el-dialog>

    <!-- æ–‡æœ¬é€‰ä¸­æµ®åŠ¨å›¾æ ‡ -->
    <div v-if="textSelection.visible" class="text-selection-popup"
        :style="{ left: textSelection.x + 'px', top: textSelection.y + 'px' }">
        <el-button type="primary" size="small" circle @click="openQuickRuleDialog">
            <el-icon>
                <component :is="Plus" />
            </el-icon>
        </el-button>
    </div>
</div>

<!-- ==================== Vue åº”ç”¨é€»è¾‘ ==================== -->
<script>
    const { createApp, ref, computed, onMounted, watch } = Vue;
    const { ElMessage, ElMessageBox } = ElementPlus;
    const { UploadFilled, Plus, WarningFilled } = ElementPlusIconsVue;

    // Element Plus ä¸­æ–‡é…ç½®
    const zhCn = {
        el: {
            table: { confirmFilter: 'ç¡®å®š', resetFilter: 'æ¸…ç©º', clearFilter: 'æ¸…ç©º', sumText: 'åˆè®¡' },
            pagination: { goto: 'å‰å¾€', pagesize: 'æ¡/é¡µ', total: 'å…± {total} æ¡', pageClassifier: 'é¡µ', page: 'é¡µ', prev: 'ä¸Šä¸€é¡µ', next: 'ä¸‹ä¸€é¡µ' },
            select: { loading: 'åŠ è½½ä¸­', noMatch: 'æ— åŒ¹é…æ•°æ®', noData: 'æ— æ•°æ®', placeholder: 'è¯·é€‰æ‹©' }
        }
    };

    const app = createApp({
        delimiters: ['[[', ']]'],
        setup() {
            // ==================== å“åº”å¼çŠ¶æ€ ====================
            const bills = ref([]);
            const loading = ref(false);
            const isEditing = ref(false);
            const hasCache = ref(false);
            const billType = ref('alipay');

            // ç­›é€‰çŠ¶æ€
            const searchQuery = ref('');
            const searchField = ref('');
            const mealType = ref('');
            const showUntaggedOnly = ref(false);
            const sortField = ref('äº¤æ˜“æ—¶é—´');
            const sortOrder = ref('ascending');
            const frequencySortField = ref(''); // é¢‘ç‡æ’åºå­—æ®µ

            // åˆ†ç±»æ•°æ®
            const categories = ref([]);
            const categoryTags = ref({});
            const categoryMeta = ref({});

            // åˆ†é¡µçŠ¶æ€
            const currentPage = ref(1);
            const pageSize = ref(20);

            // æ‰¹é‡æ‰“æ ‡
            const selectedBills = ref([]);
            const batchTagDialogVisible = ref(false);
            const batchTagForm = ref({ category: '', tag: '', comment: '' });

            // ç»Ÿè®¡ä¿¡æ¯ï¼ˆé»˜è®¤å€¼ï¼‰
            const DEFAULT_STATS = { total: 0, tagged: 0, percentage: 0, categoryTagged: 0, categoryPercentage: 0, tagTagged: 0, tagPercentage: 0 };
            const billStats = ref({ ...DEFAULT_STATS });

            // AI æ‰“æ ‡ç›¸å…³çŠ¶æ€
            const aiTagLoading = ref(false);
            const aiTagDialogVisible = ref(false);
            const aiTagResults = ref({ tagged_bills: [], suggested_rules: [] });
            const selectedAITags = ref([]);
            const selectedRules = ref([]);
            const saveSelectedRules = ref(true);

            // æ–‡æœ¬é€‰ä¸­å¿«é€Ÿåˆ›å»ºè§„åˆ™ç›¸å…³çŠ¶æ€
            const textSelection = ref({ visible: false, x: 0, y: 0, text: '', field: '', row: null });
            const quickRuleDialogVisible = ref(false);
            const quickRuleForm = ref({ key: '', keyword: '', category: '', tag: '', comment: '', time_based: ['å…¨éƒ¨'] });

            // æ—¶é—´å½’ç±»é€‰é¡¹å¸¸é‡
            const TIME_OPTIONS = ['å…¨éƒ¨', 'æ—©é¤', 'åˆé¤', 'æ™šé¤', 'å¤œå®µ'];
            const MEAL_OPTIONS = ['æ—©é¤', 'åˆé¤', 'æ™šé¤', 'å¤œå®µ'];

            /** æ—¶é—´å½’ç±»äº’æ–¥å¤„ç†ï¼š"å…¨éƒ¨"ä¸å…·ä½“é¤æ—¶äº’æ–¥ */
            const handleQuickRuleTimeBasedChange = (val) => {
                if (val.includes('å…¨éƒ¨') && val.length > 1) {
                    const lastSelected = val[val.length - 1];
                    if (lastSelected === 'å…¨éƒ¨') {
                        quickRuleForm.value.time_based = ['å…¨éƒ¨'];
                    } else {
                        quickRuleForm.value.time_based = val.filter(t => t !== 'å…¨éƒ¨');
                    }
                }
                // å››ä¸ªé¤æ—¶å…¨é€‰æ—¶è‡ªåŠ¨åˆå¹¶ä¸º"å…¨éƒ¨"
                const current = quickRuleForm.value.time_based;
                if (!current.includes('å…¨éƒ¨') && MEAL_OPTIONS.every(m => current.includes(m))) {
                    quickRuleForm.value.time_based = ['å…¨éƒ¨'];
                }
            };

            // ==================== è¾…åŠ©å‡½æ•° ====================

            /** é€šç”¨ API è°ƒç”¨ */
            const apiCall = async (method, url, data = null) => {
                try {
                    const resp = method === 'get' ? await axios.get(url) : await axios.post(url, data);
                    return resp.data.success ? resp.data : null;
                } catch (e) {
                    console.error(`API é”™è¯¯ [${url}]:`, e);
                    return null;
                }
            };

            /** æ ‡è®°æ•°æ®å·²ä¿®æ”¹ */
            const markModified = (row) => row && (row._modified = true);

            /** ç”Ÿæˆå”¯ä¸€è®¢å•å· */
            const generateOrderId = () => `${billType.value === 'wechat' ? 'WECHAT' : 'ALI'}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            /** é¤ç‚¹æ—¶é—´åˆ¤æ–­ */
            const getMealTimeRange = (meal) => ({
                'æ—©é¤': [6, 11], 'åˆé¤': [11, 14], 'æ™šé¤': [17, 20], 'å¤œå®µ': [[20, 24], [0, 3]]
            })[meal];

            const isInMealTime = (bill, meal) => {
                if (!meal) return true;
                const time = new Date(bill.äº¤æ˜“æ—¶é—´);
                const h = time.getHours() + time.getMinutes() / 60;
                const range = getMealTimeRange(meal);
                if (meal === 'å¤œå®µ') return (h >= 20 && h < 24) || (h >= 0 && h < 3);
                return h >= range[0] && h < range[1];
            };

            const defaultCategoryColor = '#409EFF';
            const fallbackCategoryIconComponent =
                ElementPlusIconsVue.Coin || ElementPlusIconsVue.Grid || ElementPlusIconsVue.CollectionTag;

            const getCategoryColor = (category) => {
                if (!category) return defaultCategoryColor;
                return categoryMeta.value?.[category]?.color || defaultCategoryColor;
            };

            const getCategoryIconComponent = (category) => {
                if (!category) return fallbackCategoryIconComponent;
                const iconName = categoryMeta.value?.[category]?.icon;
                if (!iconName) return fallbackCategoryIconComponent;
                const filledIcon = ElementPlusIconsVue[`${iconName}Filled`];
                return filledIcon || ElementPlusIconsVue[iconName] || fallbackCategoryIconComponent;
            };

            const hexToRgba = (hex, alpha) => {
                if (!hex) return `rgba(64,158,255,${alpha})`;
                const normalized = hex.replace('#', '');
                if (!/^[0-9A-Fa-f]{6}$/.test(normalized)) return hex;
                const bigint = parseInt(normalized, 16);
                const r = (bigint >> 16) & 255;
                const g = (bigint >> 8) & 255;
                const b = bigint & 255;
                return `rgba(${r},${g},${b},${alpha})`;
            };

            const getCategoryTagStyle = (category) => {
                const color = getCategoryColor(category);
                return {
                    color: color,
                    borderColor: hexToRgba(color, 0.35),
                    backgroundColor: hexToRgba(color, 0.1)
                };
            };

            const getCategoryIconTagStyle = (category) => {
                const color = getCategoryColor(category);
                return {
                    color: '#FFFFFF',
                    borderColor: color,
                    backgroundColor: color,
                    width: '24px',
                    height: '24px',
                    padding: '0',
                    borderRadius: '2px',
                    display: 'inline-flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                };
            };

            /** æœç´¢åŒ¹é… */
            const matchSearch = (bill, query, field) => {
                if (!query) return true;
                const q = query.toLowerCase();
                const fields = field === '' ? ['äº¤æ˜“æ—¶é—´', 'é‡‘é¢', 'ç±»åˆ«', 'æ ‡ç­¾', 'äº¤æ˜“å¯¹æ–¹', 'å•†å“è¯´æ˜', 'å¤‡æ³¨', 'å‘½ä¸­è§„åˆ™'] : [field];
                return fields.some(f => {
                    const v = String(bill[f] || '');
                    return q === 'null' ? !v.trim() : v.toLowerCase().includes(q);
                });
            };

            // ==================== æ ¸å¿ƒç­›é€‰é€»è¾‘ï¼ˆç»Ÿä¸€ï¼‰ ====================

            /** åº”ç”¨æ‰€æœ‰ç­›é€‰æ¡ä»¶ */
            const applyFilters = (data) => {
                let result = [...data];
                // é¤ç‚¹ç­›é€‰
                if (mealType.value) result = result.filter(b => isInMealTime(b, mealType.value));
                // æœç´¢ç­›é€‰
                if (searchQuery.value) result = result.filter(b => matchSearch(b, searchQuery.value, searchField.value));
                // æœªæ ‡è®°ç­›é€‰
                if (showUntaggedOnly.value) result = result.filter(b => !b.ç±»åˆ«?.trim());
                // æ’åº
                if (frequencySortField.value) {
                    const field = frequencySortField.value;
                    const freqMap = {};
                    result.forEach(b => {
                        const val = b[field] || '';
                        freqMap[val] = (freqMap[val] || 0) + 1;
                    });

                    result.sort((a, b) => {
                        const valA = a[field] || '';
                        const valB = b[field] || '';
                        const countA = freqMap[valA] || 0;
                        const countB = freqMap[valB] || 0;
                        if (countA !== countB) return countB - countA; // é¢‘ç‡é™åº
                        // é¢‘ç‡ç›¸åŒæ—¶ï¼ŒæŒ‰äº¤æ˜“æ—¶é—´é™åº
                        return new Date(b.äº¤æ˜“æ—¶é—´) - new Date(a.äº¤æ˜“æ—¶é—´);
                    });
                } else if (sortField.value && sortOrder.value) {
                    result.sort((a, b) => {
                        const av = a[sortField.value], bv = b[sortField.value];
                        let cmp = 0;
                        if (sortField.value === 'é‡‘é¢') cmp = (parseFloat(av) || 0) - (parseFloat(bv) || 0);
                        else if (sortField.value === 'äº¤æ˜“æ—¶é—´') cmp = new Date(av) - new Date(bv);
                        else cmp = String(av || '').localeCompare(String(bv || ''));
                        return sortOrder.value === 'ascending' ? cmp : -cmp; // æ³¨æ„ï¼šelement-plus æ’åºå¯èƒ½æ˜¯ 'ascending'/'descending'
                    });
                }
                return result;
            };

            /** é‡ç½®ç­›é€‰ */
            const resetFilters = () => {
                searchQuery.value = '';
                searchField.value = '';
                mealType.value = '';
                showUntaggedOnly.value = false;
                frequencySortField.value = '';
                sortField.value = 'äº¤æ˜“æ—¶é—´';
                sortOrder.value = 'ascending';
                // handleFilterChange åªæ˜¯é‡ç½®é¡µç ï¼ŒapplyFilters æ˜¯ computed è‡ªåŠ¨è§¦å‘
                currentPage.value = 1;
            };

            // ç­›é€‰åçš„æ•°æ®
            const filteredBillsData = computed(() => applyFilters(bills.value));

            // åˆ†é¡µæ•°æ®
            const paginatedBills = computed(() => {
                const start = (currentPage.value - 1) * pageSize.value;
                return filteredBillsData.value.slice(start, start + pageSize.value);
            });

            // ç©ºæ•°æ®æç¤º
            const emptyText = computed(() => bills.value.length ? 'æ²¡æœ‰ç¬¦åˆæ¡ä»¶çš„æ•°æ®' : 'æœªä¸Šä¼ æ–‡ä»¶');

            // ç­›é€‰é€‰é¡¹
            const generateFilters = (field) => {
                const vals = [...new Set(filteredBillsData.value.map(b => b[field]))].filter(Boolean);
                return [{ text: '(ç©º)', value: '' }, ...vals.map(v => ({ text: v, value: v }))];
            };
            const categoryFilterOptions = computed(() => generateFilters('ç±»åˆ«'));
            const tagFilterOptions = computed(() => generateFilters('æ ‡ç­¾'));
            const filterCategory = (value, row) => value === '' ? !row.ç±»åˆ«?.trim() : row.ç±»åˆ« === value;
            const filterTag = (value, row) => value === '' ? !row.æ ‡ç­¾?.trim() : row.æ ‡ç­¾ === value;

            // ==================== æ•°æ®åŠ è½½ ====================

            /** è·å–è´¦å• */
            const fetchBills = async () => {
                loading.value = true;
                const data = await apiCall('get', '/api/bills');
                bills.value = data?.bills || [];
                await fetchStats();
                loading.value = false;
            };

            /** è·å–ç»Ÿè®¡ */
            const fetchStats = async () => {
                const data = await apiCall('get', '/api/bill_stats');
                billStats.value = data?.stats || { ...DEFAULT_STATS };
            };

            /** è·å–åˆ†ç±» */
            const fetchCategories = async () => {
                const data = await apiCall('get', '/api/categories');
                if (data) {
                    categories.value = Object.keys(data.categories);
                    categoryTags.value = data.categories;
                    categoryMeta.value = data.meta || {};
                }
            };

            /** æ£€æŸ¥å¹¶åŠ è½½ç¼“å­˜ */
            const checkProgress = async (silent = false) => {
                const data = await apiCall('get', '/api/check_progress');
                hasCache.value = data?.has_progress || false;
                if (hasCache.value) {
                    const loadData = await apiCall('get', '/api/load_progress');
                    if (loadData?.bills) {
                        bills.value = Array.isArray(loadData.bills) ? loadData.bills : Object.values(loadData.bills);
                        await fetchStats();
                        if (!silent) ElMessage.success('æˆåŠŸåŠ è½½ç¼“å­˜æ•°æ®');
                    }
                } else {
                    await fetchBills();
                }
            };

            // ==================== äº‹ä»¶å¤„ç† ====================

            /** ç­›é€‰å˜åŒ– */
            const handleFilterChange = () => {
                currentPage.value = 1;
                // ä½¿ç”¨ computed è‡ªåŠ¨æ›´æ–°ï¼Œæ— éœ€æ‰‹åŠ¨è°ƒç”¨
            };

            /** æ’åºå˜åŒ– */
            const handleSortChange = ({ prop, order }) => {
                sortField.value = prop;
                sortOrder.value = order;
            };

            /** ç±»åˆ«å˜åŒ–æ—¶æ¸…ç©ºæ ‡ç­¾ */
            const handleCategoryChange = (row) => {
                row.æ ‡ç­¾ = '';
                markModified(row);
            };

            /** è·å–ç±»åˆ«å¯¹åº”çš„æ ‡ç­¾ */
            const getTagsForCategory = (cat) => categoryTags.value[cat] || [];

            /** è¡¨æ ¼é€‰æ‹©å˜åŒ– */
            const handleSelectionChange = (selection) => selectedBills.value = selection;

            // ==================== æ‰“æ ‡æ“ä½œ ====================

            /** å¼€å§‹/ä¿å­˜æ‰“æ ‡ */
            const handleStartTagging = async () => {
                if (isEditing.value) {
                    // ä¿å­˜è¿›åº¦
                    const billsToSave = bills.value.map(b => b.äº¤æ˜“è®¢å•å· ? b : { ...b, äº¤æ˜“è®¢å•å·: generateOrderId() });
                    const resp = await apiCall('post', '/api/save_progress', { bills: billsToSave });
                    if (resp) {
                        isEditing.value = false;
                        hasCache.value = true;
                        showUntaggedOnly.value = false;
                        ElMessage.success('ä¿å­˜è¿›åº¦æˆåŠŸ');
                        await checkProgress(true);
                    } else {
                        ElMessage.error('ä¿å­˜è¿›åº¦å¤±è´¥');
                    }
                } else {
                    // è¿›å…¥æ‰“æ ‡æ¨¡å¼
                    await fetchCategories();
                    isEditing.value = true;
                    showUntaggedOnly.value = true;
                    ElMessage.warning('å¯¹ â€œäº¤æ˜“å¯¹æ–¹â€ å’Œâ€œå•†å“è¯´æ˜â€ åˆ’è¯å¯ä»¥å¿«é€Ÿæ–°å¢æ‰“æ ‡è§„åˆ™');
                }
            };

            /** AI æ‰“æ ‡ */
            const handleAITag = async () => {
                // è·å–å½“å‰ç­›é€‰åçš„æœªæ‰“æ ‡è´¦å•
                const untaggedBills = filteredBillsData.value.filter(b => !b.ç±»åˆ«?.trim());
                if (untaggedBills.length === 0) {
                    return ElMessage.info('å½“å‰ç­›é€‰ç»“æœä¸­æ²¡æœ‰æœªæ‰“æ ‡çš„è´¦å•');
                }

                aiTagLoading.value = true;
                try {
                    // æŠŠå½“å‰ç­›é€‰åçš„æ•°æ®å‘ç»™åç«¯
                    const resp = await axios.post('/api/ai_tag', { bills: untaggedBills });
                    if (resp.data.success) {
                        aiTagResults.value = {
                            tagged_bills: resp.data.tagged_bills || [],
                            suggested_rules: resp.data.suggested_rules || [],
                        };
                        if (aiTagResults.value.tagged_bills.length === 0) {
                            ElMessage.info('æ²¡æœ‰æ‰¾åˆ°æœªæ‰“æ ‡çš„è´¦å•');
                        } else {
                            aiTagDialogVisible.value = true;
                            // é»˜è®¤å…¨é€‰æ‰“æ ‡ç»“æœ
                            selectedAITags.value = [...aiTagResults.value.tagged_bills];
                        }
                    } else {
                        ElMessage.error(resp.data.message || 'AI æ‰“æ ‡å¤±è´¥');
                    }
                } catch (e) {
                    console.error('AI æ‰“æ ‡é”™è¯¯:', e);
                    ElMessage.error(e.response?.data?.message || 'AI æ‰“æ ‡è¯·æ±‚å¤±è´¥');
                }
                aiTagLoading.value = false;
            };

            /** AI æ‰“æ ‡ç»“æœé€‰æ‹© */
            const handleAITagSelection = (selection) => selectedAITags.value = selection;
            const handleRuleSelection = (selection) => selectedRules.value = selection;

            /** åº”ç”¨ AI æ‰“æ ‡ç»“æœ */
            const applyAITagResults = async () => {
                if (!selectedAITags.value.length) return ElMessage.warning('è¯·é€‰æ‹©è¦åº”ç”¨çš„æ‰“æ ‡ç»“æœ');

                try {
                    const resp = await axios.post('/api/apply_ai_tags', {
                        tagged_bills: selectedAITags.value,
                        save_rules: saveSelectedRules.value && selectedRules.value.length > 0,
                        selected_rules: selectedRules.value,
                    });

                    if (resp.data.success) {
                        ElMessage.success(resp.data.message);
                        aiTagDialogVisible.value = false;
                        await checkProgress(true);
                    } else {
                        ElMessage.error(resp.data.message || 'åº”ç”¨å¤±è´¥');
                    }
                } catch (e) {
                    ElMessage.error('åº”ç”¨æ‰“æ ‡ç»“æœå¤±è´¥');
                }
            };

            // ==================== æ–‡æœ¬é€‰ä¸­å¿«é€Ÿåˆ›å»ºè§„åˆ™ ====================

            /** å¤„ç†æ–‡æœ¬é€‰ä¸­ */
            const handleTextSelect = (event, field, row) => {
                // å…è®¸åœ¨ç¼–è¾‘æ¨¡å¼ä¸‹ä½¿ç”¨ï¼ˆç”¨æˆ·éœ€æ±‚ï¼‰
                // if (isEditing.value) { ... }

                const selection = window.getSelection();
                const text = selection.toString().trim();

                if (text && text.length > 0) {
                    // è®¡ç®—æµ®åŠ¨å›¾æ ‡ä½ç½®
                    const rect = selection.getRangeAt(0).getBoundingClientRect();
                    textSelection.value = {
                        visible: true,
                        x: rect.right + 5,
                        y: rect.top - 5,
                        text: text,
                        field: field,
                        row: row,
                    };
                } else {
                    textSelection.value.visible = false;
                }
            };

            /** æ‰“å¼€å¿«é€Ÿè§„åˆ™å¼¹æ¡† */
            const openQuickRuleDialog = async () => {
                await fetchCategories();
                quickRuleForm.value = {
                    key: textSelection.value.field,
                    keyword: textSelection.value.text,
                    match_mode: 'keyword',
                    category: '',
                    tag: '',
                    comment: '',
                    time_based: ['å…¨éƒ¨'],
                };
                textSelection.value.visible = false;
                quickRuleDialogVisible.value = true;
            };

            /** ä¿å­˜å¿«é€Ÿè§„åˆ™ */
            const saveQuickRule = async () => {
                // æ­£åˆ™æ ¡éªŒ
                if (quickRuleForm.value.match_mode === 'regex') {
                    try {
                        new RegExp(quickRuleForm.value.keyword);
                    } catch (e) {
                        return ElMessage.error('æ— æ•ˆçš„æ­£åˆ™è¡¨è¾¾å¼ï¼š' + e.message);
                    }
                }

                const rule = {
                    key: quickRuleForm.value.key,
                    match_mode: quickRuleForm.value.match_mode,
                    rule: [quickRuleForm.value.keyword],
                    category: quickRuleForm.value.category,
                    tag: quickRuleForm.value.tag || '-',
                    time_based: (quickRuleForm.value.category === 'é£Ÿ' && (!quickRuleForm.value.tag || quickRuleForm.value.tag === '-')) ? quickRuleForm.value.time_based : [],
                    comment: quickRuleForm.value.comment,
                };

                try {
                    // è°ƒç”¨åç«¯åˆå¹¶è§„åˆ™
                    const resp = await axios.post('/api/apply_ai_tags', {
                        tagged_bills: [],
                        save_rules: true,
                        selected_rules: [rule],
                    });

                    if (resp.data.success) {
                        ElMessage.success('è§„åˆ™ä¿å­˜æˆåŠŸï¼Œå·²è§¦å‘è‡ªåŠ¨æ‰“æ ‡');
                        quickRuleDialogVisible.value = false;
                        // è°ƒç”¨åç«¯é‡æ–°åº”ç”¨æ‰“æ ‡è§„åˆ™
                        await axios.post('/api/auto_tag');
                        // åˆ·æ–°æ•°æ®
                        await checkProgress(true);
                    } else {
                        ElMessage.error(resp.data.message || 'ä¿å­˜å¤±è´¥');
                    }
                } catch (e) {
                    ElMessage.error('ä¿å­˜è§„åˆ™å¤±è´¥');
                }
            };

            /** æ£€æŸ¥æ˜¯å¦ä¸ºæ–°ç±»åˆ« */
            const isNewCategory = computed(() => {
                const cat = quickRuleForm.value.category;
                return cat && !categories.value.includes(cat);
            });

            /** æ£€æŸ¥æ˜¯å¦ä¸ºæ–°æ ‡ç­¾ */
            const isNewTag = computed(() => {
                const tag = quickRuleForm.value.tag;
                if (!tag || tag === '-') return false;
                const existingTags = categoryTags.value[quickRuleForm.value.category] || [];
                return !existingTags.includes(tag);
            });

            // ç‚¹å‡»å…¶ä»–åŒºåŸŸéšè—æµ®åŠ¨å›¾æ ‡
            document.addEventListener('mousedown', (e) => {
                if (!e.target.closest('.text-selection-popup') && !e.target.closest('.selectable-text')) {
                    textSelection.value.visible = false;
                }
            });

            /** æ‰¹é‡æ‰“æ ‡ */
            const handleBatchTag = () => {
                if (!selectedBills.value.length) return ElMessage.warning('è¯·å…ˆé€‰æ‹©è¦æ‰“æ ‡çš„è´¦å•');
                batchTagDialogVisible.value = true;
            };

            const applyBatchTag = () => {
                const { category, tag, comment } = batchTagForm.value;
                if (!category && !tag && !comment) return ElMessage.warning('è¯·è‡³å°‘å¡«å†™ä¸€ä¸ªæ‰“æ ‡é¡¹');
                selectedBills.value.forEach(b => {
                    if (category) b.ç±»åˆ« = category;
                    if (tag) b.æ ‡ç­¾ = tag;
                    if (comment) b.å¤‡æ³¨ = comment;
                });
                batchTagDialogVisible.value = false;
                batchTagForm.value = { category: '', tag: '', comment: '' };
                ElMessage.success('æ‰¹é‡æ‰“æ ‡æˆåŠŸ');
            };

            // ==================== æ–‡ä»¶æ“ä½œ ====================

            /** ä¸Šä¼ å‰æ£€æŸ¥ */
            const beforeUpload = async (file) => {
                if (!file.name.endsWith('.xlsx') && !file.name.endsWith('.csv')) {
                    ElMessage.error('åªèƒ½ä¸Šä¼  xlsx æˆ– csv æ–‡ä»¶ï¼');
                    return false;
                }
                const data = await apiCall('get', '/api/check_progress');
                if (data?.has_progress) {
                    try {
                        await ElMessageBox.confirm('å·²æœ‰æœªå®Œæˆçš„è¿›åº¦ï¼Œå†æ¬¡ä¸Šä¼ å°†è¦†ç›–å½“å‰è¿›åº¦', 'è­¦å‘Š', {
                            confirmButtonText: 'ç»§ç»­',
                            cancelButtonText: 'å–æ¶ˆ',
                            type: 'warning'
                        });
                        return true;
                    } catch { return false; }
                }
                return true;
            };

            /** ä¸Šä¼ æˆåŠŸ */
            const handleUploadSuccess = async (response) => {
                if (response.success) {
                    ElMessage.success('ä¸Šä¼ æˆåŠŸ');
                    await fetchBills();
                    // è‡ªåŠ¨æ‰“æ ‡
                    const resp = await apiCall('post', '/api/auto_tag');
                    if (resp) await fetchBills();
                } else {
                    ElMessage.error(response.message || 'ä¸Šä¼ å¤±è´¥');
                }
            };

            const handleUploadError = () => ElMessage.error('ä¸Šä¼ å¤±è´¥');

            /** å¯¼å‡ºè´¦å• */
            const handleExport = async () => {
                if (!filteredBillsData.value.length) return ElMessage.warning('æ²¡æœ‰å¯å¯¼å‡ºçš„æ•°æ®');
                try {
                    const resp = await axios.post('/api/export', { bills: filteredBillsData.value }, { responseType: 'blob' });
                    const url = window.URL.createObjectURL(new Blob([resp.data]));
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `è´¦å•æ•°æ®_${new Date().toLocaleDateString()}.xlsx`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    window.URL.revokeObjectURL(url);
                    ElMessage.success('å¯¼å‡ºæˆåŠŸ');
                } catch { ElMessage.error('å¯¼å‡ºå¤±è´¥'); }
            };

            /** æ¸…é™¤ç¼“å­˜ */
            const handleClearCache = async () => {
                try {
                    await ElMessageBox.confirm('ç¡®å®šè¦æ¸…é™¤ç¼“å­˜æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤', 'è­¦å‘Š', {
                        confirmButtonText: 'ç¡®å®š',
                        cancelButtonText: 'å–æ¶ˆ',
                        type: 'warning'
                    });
                    const resp = await apiCall('post', '/api/clear_cache');
                    if (resp) {
                        hasCache.value = false;
                        bills.value = [];
                        await fetchBills();
                        ElMessage.success('ç¼“å­˜å·²æ¸…é™¤');
                    }
                } catch { }
            };

            // ==================== ç”Ÿå‘½å‘¨æœŸ ====================

            onMounted(async () => {
                await Promise.all([checkProgress(), fetchCategories()]);
            });

            // ==================== è¿”å›æ¨¡æ¿ç»‘å®š ====================

            return {
                // çŠ¶æ€
                bills, loading, isEditing, hasCache, billType, billStats,
                searchQuery, searchField, mealType, showUntaggedOnly,
                categories, categoryTags, currentPage, pageSize,
                selectedBills, batchTagDialogVisible, batchTagForm,
                // AI æ‰“æ ‡çŠ¶æ€
                aiTagLoading, aiTagDialogVisible, aiTagResults,
                selectedAITags, selectedRules, saveSelectedRules,
                // å¿«é€Ÿè§„åˆ™çŠ¶æ€
                textSelection, quickRuleDialogVisible, quickRuleForm, TIME_OPTIONS,
                // è®¡ç®—å±æ€§
                filteredBillsData, paginatedBills, emptyText,
                categoryFilterOptions, tagFilterOptions,
                // æ–¹æ³•
                handleFilterChange, handleSortChange, handleCategoryChange,
                getTagsForCategory, handleSelectionChange, markModified,
                handleStartTagging, handleBatchTag, applyBatchTag,
                // AI æ‰“æ ‡æ–¹æ³•
                handleAITag, handleAITagSelection, handleRuleSelection, applyAITagResults,
                // å¿«é€Ÿè§„åˆ™æ–¹æ³•
                handleTextSelect, openQuickRuleDialog, saveQuickRule, handleQuickRuleTimeBasedChange,
                isNewCategory, isNewTag,
                beforeUpload, handleUploadSuccess, handleUploadError,
                handleExport, handleClearCache,
                resetFilters, frequencySortField, // å¯¼å‡º
                filterCategory, filterTag, formatAmount,
                getCategoryTagStyle, getCategoryIconComponent, getCategoryIconTagStyle,
                UploadFilled, Plus, WarningFilled
            };
        }
    });

    // æ³¨å†Œæ‰€æœ‰å›¾æ ‡
    for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
        app.component(key, component)
    }

    app.use(ElementPlus, { locale: zhCn });
    app.mount('#app');
</script>
{% endblock %}