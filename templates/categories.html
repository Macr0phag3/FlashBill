{% extends "base.html" %}

{% block head %}
{{ super() }}
<!-- 注：Vue/Element Plus 已在 base.html 引入，此处仅引入额外样式 -->
{% endblock %}

{% block page_loader %}
{% include 'loader.html' %}
{% endblock %}

{% block content %}
<!-- ==================== 分类管理界面 ==================== -->
<div id="app" v-cloak>
    <el-card class="mb-3">
        <template #header>
            <div class="d-flex justify-content-between align-items-center">
                <span>分类管理</span>
                <div class="d-flex gap-2">
                    <el-button type="primary" @click="addCategory">添加分类</el-button>
                    <el-button type="success" @click="saveCategories">保存分类</el-button>
                </div>
            </div>
        </template>

        <!-- 分类表格 -->
        <div class="categories-table-container" v-loading="loading">
            <el-table :data="categories" class="categories-table-full" stripe height="100%">
                <!-- 分类名称列 -->
                <el-table-column label="分类名称" width="100" align="left" header-align="left">
                    <template #default="scope">
                        <div class="d-flex align-items-center justify-content-start gap-1">
                            <el-popover trigger="click" placement="bottom-start" :width="260"
                                @show="handleIconPopoverShow(scope.$index)">
                                <template #reference>
                                    <el-button size="small" circle class="icon-picker-btn">
                                        <el-icon size="16" :style="{ color: scope.row.color || defaultTagColor }">
                                            <component :is="scope.row.icon || defaultCategoryIcon" />
                                        </el-icon>
                                    </el-button>
                                </template>
                                <div class="d-flex align-items-center gap-2">
                                    <el-color-picker v-model="scope.row.color" size="small" :teleported="false"
                                        :class="{ 'default-color': !scope.row.color }"></el-color-picker>
                                    <el-select v-model="scope.row.icon" placeholder="选择图标" filterable clearable
                                        size="small" class="categories-icon-select" :teleported="false"
                                        :ref="el => setIconSelectRef(scope.$index, el)">
                                        <el-option v-for="iconName in iconList" :key="iconName" :label="iconName"
                                            :value="iconName">
                                            <span class="categories-icon-option-left">
                                                <el-icon>
                                                    <component :is="iconName" />
                                                </el-icon>
                                            </span>
                                            <span class="categories-icon-option-right">
                                                [[ iconName ]]
                                            </span>
                                        </el-option>
                                    </el-select>
                                </div>
                            </el-popover>
                            <el-input v-model="scope.row.name" size="small" placeholder="请输入分类名称"
                                class="categories-name-input stealth-input"></el-input>
                        </div>
                    </template>
                </el-table-column>

                <!-- 标签列 -->
                <el-table-column label="标签" header-align="center">
                    <template #default="scope">
                        <div class="d-flex align-items-center gap-2">
                            <div class="d-flex flex-wrap align-items-center gap-2 categories-tags-wrap">
                                <el-tag v-for="(tag, tagIndex) in scope.row.tags" :key="tagIndex" closable
                                    :type="getTagType(scope.row.name, tag)"
                                    :style="getTagStyle(scope.row.name, tag, scope.row.color)" :class="{ 
                                        'tag-deleted': isDeletedTag(scope.row.name, tag),
                                        'is-custom-color': !getTagType(scope.row.name, tag) && scope.row.color 
                                    }" @close="handleTagClose(scope.$index, tagIndex, scope.row.name, tag)"
                                    class="tag-item">
                                    [[ tag ]]
                                </el-tag>
                            </div>
                            <el-input v-if="scope.row.inputVisible" v-model="scope.row.inputValue" class="tag-input"
                                size="small" @keyup.enter="handleInputConfirm(scope.row.name)"
                                @blur="handleInputConfirm(scope.row.name)">
                            </el-input>
                            <el-button v-else class="button-new-tag" size="small" @click="showInput(scope.$index)">
                                + 新标签
                            </el-button>
                        </div>
                    </template>
                </el-table-column>

                <!-- 操作列 -->
                <el-table-column label="操作" width="100" align="center">
                    <template #default="scope">
                        <el-button type="danger" size="small" @click="removeCategory(scope.$index)">删除</el-button>
                    </template>
                </el-table-column>
            </el-table>
        </div>
    </el-card>
</div>

<!-- ==================== Vue 应用逻辑 ==================== -->
<script>
    const { createApp, ref, onMounted, nextTick } = Vue;
    const { ElMessage, ElMessageBox } = ElementPlus;
    // 获取所有 Element Plus 图标组件
    const ElementPlusIcons = ElementPlusIconsVue;

    const app = createApp({
        delimiters: ['[[', ']]'],
        setup() {
            const categories = ref([]);
            const loading = ref(false);
            const newTagItems = ref(new Set()); // 追踪新增的标签项
            const deletedTagItems = ref(new Set()); // 追踪软删除的标签项
            const iconSelectRefs = ref({});

            // 图标列表（从 ElementPlusIconsVue 获取所有图标名称）
            const iconList = Object.keys(ElementPlusIcons);
            const defaultCategoryIcon = iconList.includes('Coin') ? 'Coin' : 'Grid';
            const defaultTagColor = '#409EFF';

            const setIconSelectRef = (index, el) => {
                if (el) {
                    iconSelectRefs.value[index] = el;
                } else {
                    delete iconSelectRefs.value[index];
                }
            };

            const handleIconPopoverShow = (index) => {
                nextTick(() => {
                    const selectRef = iconSelectRefs.value[index];
                    if (selectRef?.focus) selectRef.focus();
                });
            };

            const runWhenIdle = (fn) => {
                if (window.requestIdleCallback) {
                    window.requestIdleCallback(fn, { timeout: 500 });
                } else {
                    setTimeout(fn, 0);
                }
            };

            // ==================== API 辅助函数 ====================

            /** 通用 API 调用封装 */
            const apiCall = async (method, url, data = null, successMsg = null) => {
                try {
                    const response = method === 'get'
                        ? await axios.get(url)
                        : await axios.post(url, data);
                    if (response.data.success) {
                        if (successMsg) ElMessage.success(successMsg);
                        return response.data;
                    }
                    throw new Error(response.data.message || '操作失败');
                } catch (error) {
                    console.error(`API 调用失败 [${url}]:`, error);
                    ElMessage.error(error.message || '操作失败');
                    return null;
                }
            };

            // ==================== 数据加载 ====================

            /** 获取分类数据 */
            const fetchCategories = async (assign = true, withDiff = true) => {
                loading.value = true;
                try {
                    const data = await apiCall('get', '/api/categories');
                    if (data) {
                        const meta = data.meta || {};
                        const processed = Object.entries(data.categories).map(([name, tags]) => ({
                            name,
                            tags,
                            icon: meta[name]?.icon || defaultCategoryIcon,
                            color: meta[name]?.color || defaultTagColor,
                            inputVisible: false,
                            inputValue: ''
                        }));
                        if (assign) categories.value = processed;
                        if (withDiff) await checkCategoriesDiff(data.categories);
                        return { processed, rawCategories: data.categories };
                    }
                    return { processed: [], rawCategories: {} };
                } finally {
                    loading.value = false;
                }
            };

            // ==================== 差异检测 ====================

            /** 差异类型映射 */
            const DIFF_TYPES = {
                missing_category: { text: '缺失分类' },
                missing_tags: { text: '缺失标签' },
                extra_category: { text: '多余分类' },
                extra_tags: { text: '多余标签' }
            };

            /** 检查分类与 DB.xlsx 的差异 */
            const checkCategoriesDiff = async (currentCategories) => {
                const data = await apiCall('get', '/api/statistics?limit=1');
                if (!data?.all_items?.length) return;

                // 从 DB 数据提取分类和标签
                const dbCategories = {};
                data.all_items.forEach(({ category, tag }) => {
                    if (category?.trim()) {
                        dbCategories[category] = dbCategories[category] || new Set();
                        if (tag?.trim() && tag !== '-') dbCategories[category].add(tag);
                    }
                });
                // Set 转 Array
                Object.keys(dbCategories).forEach(k => dbCategories[k] = [...dbCategories[k]]);

                const diffs = compareCategories(currentCategories, dbCategories);
                if (diffs.length) showDiffDialog(diffs, dbCategories);
            };

            /** 比较两个分类对象的差异 */
            const compareCategories = (current, db) => {
                const diffs = [];
                const addDiff = (type, category, extra = {}) => diffs.push({ type, category, ...extra });

                // 检查 DB 中的分类
                Object.keys(db).forEach(cat => {
                    if (!current[cat]) {
                        addDiff('missing_category', cat);
                    } else {
                        const currSet = new Set(current[cat] || []);
                        const dbSet = new Set(db[cat] || []);
                        const missing = [...dbSet].filter(t => !currSet.has(t));
                        const extra = [...currSet].filter(t => !dbSet.has(t));
                        if (missing.length) addDiff('missing_tags', cat, { missingTags: missing });
                        if (extra.length) addDiff('extra_tags', cat, { extraTags: extra });
                    }
                });

                // 检查 current 中多余的分类
                Object.keys(current).forEach(cat => {
                    if (!db[cat]) addDiff('extra_category', cat);
                });

                return diffs;
            };

            /** 显示差异对话框 */
            const showDiffDialog = (diffs, dbCategories) => {
                const getDetail = d => ({
                    missing_tags: `DB.xlsx中有: ${d.missingTags?.join(', ')}`,
                    extra_tags: `categories.json中有: ${d.extraTags?.join(', ')}`,
                    missing_category: 'DB.xlsx中有此分类',
                    extra_category: 'categories.json中有此分类'
                })[d.type];

                const rows = diffs.map(d => {
                    const { text } = DIFF_TYPES[d.type];
                    return `<tr>
                    <td class="categories-diff-cell">
                        <span class="categories-diff-type categories-diff-type-${d.type}">${text}</span>
                    </td>
                    <td class="categories-diff-cell">${d.category}</td>
                    <td class="categories-diff-cell">${getDetail(d)}</td>
                </tr>`;
                }).join('');

                const html = `
                <div class="categories-diff-wrap">
                    <table class="categories-diff-table">
                        <thead><tr class="categories-diff-head-row">
                            <th class="categories-diff-head">类型</th>
                            <th class="categories-diff-head">分类</th>
                            <th class="categories-diff-head">差异详情</th>
                        </tr></thead>
                        <tbody>${rows}</tbody>
                    </table>
                </div>
                <div class="categories-diff-footer">
                    共发现 ${diffs.length} 处差异
                </div>`;

                ElMessageBox.confirm(html, '分类数据差异', {
                    confirmButtonText: '使用 DB.xlsx 覆盖',
                    cancelButtonText: '保持当前设置',
                    dangerouslyUseHTMLString: true
                }).then(() => updateFromDB(dbCategories))
                    .catch(() => ElMessage.info('已保持当前分类数据'));
            };

            /** 从 DB 数据覆盖 categories.json */
            const updateFromDB = async (dbCategories) => {
                const result = await apiCall('post', '/api/categories', { categories: dbCategories }, '已使用DB.xlsx的分类数据覆盖');
                if (result) await fetchCategories();
            };

            // ==================== 分类操作 ====================

            /** 添加新分类 */
            const addCategory = () => {
                categories.value.unshift({
                    name: '',
                    tags: [],
                    icon: defaultCategoryIcon,
                    color: defaultTagColor,
                    inputVisible: false,
                    inputValue: ''
                });
            };

            /** 删除分类 */
            const removeCategory = (index) => categories.value.splice(index, 1);

            /** 显示标签输入框 */
            const showInput = (index) => categories.value[index].inputVisible = true;

            /** 确认添加标签 */
            const handleInputConfirm = (categoryName) => {
                const cat = categories.value.find(c => c.name === categoryName);
                if (!cat?.inputVisible) return;

                const newTag = cat.inputValue.trim();
                if (newTag) {
                    if (cat.tags.includes(newTag)) {
                        ElMessage.error('该标签已存在');
                    } else {
                        cat.tags.push(newTag);
                        // 记录为新增的标签项
                        newTagItems.value.add(`${cat.name}_${newTag}`);
                    }
                }
                cat.inputVisible = false;
                cat.inputValue = '';
            };

            /** 软删除标签（标记为已删除，保存后才真正移除） */
            const removeTag = (catIdx, tagIdx) => {
                const cat = categories.value[catIdx];
                const tag = cat.tags[tagIdx];
                const key = `${cat.name}_${tag}`;
                // 如果是新增的标签，直接删除而不是软删除
                if (newTagItems.value.has(key)) {
                    newTagItems.value.delete(key);
                    cat.tags.splice(tagIdx, 1);
                } else {
                    deletedTagItems.value.add(key);
                }
            };

            /** 恢复软删除的标签 */
            const restoreTag = (catName, tag) => {
                const key = `${catName}_${tag}`;
                if (deletedTagItems.value.has(key)) {
                    deletedTagItems.value.delete(key);
                }
            };

            /** 统一处理标签关闭事件：已删除则恢复，未删除则软删除 */
            const handleTagClose = (catIdx, tagIdx, catName, tag) => {
                if (isDeletedTag(catName, tag)) {
                    restoreTag(catName, tag);
                } else {
                    removeTag(catIdx, tagIdx);
                }
            };

            /** 判断是否为新增的标签 */
            const isNewTag = (catName, tag) => newTagItems.value.has(`${catName}_${tag}`);

            /** 判断是否为软删除的标签 */
            const isDeletedTag = (catName, tag) => deletedTagItems.value.has(`${catName}_${tag}`);

            /** 获取标签类型：删除=danger，新增=warning，默认='' */
            const getTagType = (catName, tag) => {
                if (isDeletedTag(catName, tag)) return 'danger';
                if (isNewTag(catName, tag)) return 'warning';
                return '';
            };

            /** Hex 转 RGBA 辅助函数 */
            const hexToRgba = (hex, alpha) => {
                let c;
                if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
                    c = hex.substring(1).split('');
                    if (c.length == 3) {
                        c = [c[0], c[0], c[1], c[1], c[2], c[2]];
                    }
                    c = '0x' + c.join('');
                    return 'rgba(' + [(c >> 16) & 255, (c >> 8) & 255, c & 255].join(',') + ',' + alpha + ')';
                }
                return hex; // 如果已经是 rgba 或无效 hex，直接返回
            }

            /** 获取标签样式 (自定义颜色适配) */
            const getTagStyle = (catName, tag, color) => {
                const type = getTagType(catName, tag);
                if (type) {
                    return isDeletedTag(catName, tag) ? { opacity: 0.7 } : {};
                }
                const effectiveColor = color || defaultTagColor;
                return {
                    backgroundColor: hexToRgba(effectiveColor, 0.1),
                    borderColor: hexToRgba(effectiveColor, 0.3),
                    color: effectiveColor,
                    '--tag-bg-color': hexToRgba(effectiveColor, 0.1), // 标签背景色，供 hover 使用
                    '--tag-icon-color': effectiveColor // 标签文字颜色，供 hover 使用
                };
            };

            /** 保存分类到服务器 */
            const saveCategories = async () => {
                const data = {};
                const meta = {};

                // 保存时过滤掉软删除的标签
                categories.value.forEach(c => {
                    if (c.name.trim()) {
                        const name = c.name.trim();
                        data[name] = c.tags.filter(tag => !deletedTagItems.value.has(`${c.name}_${tag}`));

                        // 收集元数据
                        meta[name] = {
                            icon: c.icon || defaultCategoryIcon,
                            color: c.color || defaultTagColor
                        };
                    }
                });

                const result = await apiCall('post', '/api/categories', {
                    categories: data,
                    meta: meta
                }, '保存成功');
                if (result) {
                    newTagItems.value.clear(); // 清空新增标签追踪
                    deletedTagItems.value.clear(); // 清空删除标签追踪
                    fetchCategories();
                }
            };

            // ==================== 生命周期 ====================

            onMounted(async () => {
                const loader = document.getElementById('page-loader');
                try {
                    const { processed, rawCategories } = await fetchCategories(false, false);
                    categories.value = [];
                    loading.value = true;

                    // 先渲染基础行（不带 tags），降低首屏 DOM 压力
                    const staged = processed.map((item) => ({
                        ...item,
                        __pendingTags: item.tags,
                        tags: []
                    }));

                    // 参考 rules 页面：分块渲染，避免一次性渲染导致主线程卡顿
                    const CATEGORY_CHUNK_SIZE = 2;
                    const TAG_CHUNK_SIZE = 2;
                    let currentIndex = 0;
                    const renderCategoryChunk = () => {
                        if (currentIndex < staged.length) {
                            const chunk = staged.slice(currentIndex, currentIndex + CATEGORY_CHUNK_SIZE);
                            categories.value.push(...chunk);
                            currentIndex += CATEGORY_CHUNK_SIZE;
                            requestAnimationFrame(renderCategoryChunk);
                            return;
                        }

                        // 第二阶段：分块回填 tags，进一步平滑渲染
                        let tagIndex = 0;
                        const renderTagChunk = () => {
                            const end = Math.min(tagIndex + TAG_CHUNK_SIZE, categories.value.length);
                            for (let i = tagIndex; i < end; i++) {
                                const row = categories.value[i];
                                if (row && row.__pendingTags) {
                                    row.tags = row.__pendingTags;
                                    delete row.__pendingTags;
                                }
                            }
                            tagIndex = end;
                            if (tagIndex < categories.value.length) {
                                requestAnimationFrame(renderTagChunk);
                                return;
                            }

                            loading.value = false;

                            if (loader) {
                                loader.style.opacity = '0';
                                setTimeout(() => loader.style.display = 'none', 300);
                            }

                            // 避免在 loader 动画期间做额外计算，延后到空闲时执行差异检查
                            runWhenIdle(() => checkCategoriesDiff(rawCategories));
                        };

                        requestAnimationFrame(renderTagChunk);
                    };

                    requestAnimationFrame(renderCategoryChunk);
                } catch (e) {
                    console.error('Initial load failed', e);
                    loading.value = false;
                    if (loader) loader.style.display = 'none';
                }
            });

            return {
                categories, loading, addCategory, removeCategory, showInput, handleInputConfirm, removeTag, restoreTag,
                handleTagClose, saveCategories, isNewTag, isDeletedTag, getTagType, iconList, getTagStyle,
                setIconSelectRef, handleIconPopoverShow, defaultCategoryIcon, defaultTagColor
            };
        }
    });

    app.use(ElementPlus);
    // 注册所有图标组件
    for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
        app.component(key, component)
    }
    app.mount('#app');
</script>
{% endblock %}